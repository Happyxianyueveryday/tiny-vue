## Vue双向绑定原理详解

Vue双向绑定包括从数据到视图的绑定和视图到数据的绑定，其中从视图到数据的绑定是较为简单的，当视图变化时，直接使用js中的事件监听即可完成。但是从数据到视图的绑定是难度较大的。如何实现当数据变化时视图随之更新，是本文档说明的重点。

本文档编写时的参考资料为: https://www.cnblogs.com/libin-1/p/6893712.html 。

在Vue中，从数据到视图的绑定是基于数据劫持和发布者-订阅者模式两种重要技术实现的。

### 1. 数据劫持
在js中，使用Object.defineProperty()方法实现数据劫持的，该方法的原型是：

```
/** 
 * Object.defineProperty: 精确添加或者修改对象的属性
 * param obj: 要在其上定义属性的对象
 * param prop: 要定义或修改的属性的名称
 * param descriptor: 将被定义或修改的属性描述符
 */
Object.defineProperty(obj, prop, descriptor)
```
在双向绑定的实现中，则只需要关注两个方法属性get和set，（不熟悉这两个方法属性的话可以参考https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty ） 一个示例用法如下，下述示例中劫持了Person的name属性，name属性值发生改变时指定set方法，获取name属性值时执行get方法：

```
<script>
    
    var Person={
        name: "",
    };

    Object.defineProperty(Person, "name", {   
        set: function(newname) {        // 给Person的name属性增加一个set属性，当name属性被改变时，触发执行set方法
            name=newname;
            console.log("setter已经被调用");
        },

        get: function() {               // 给Person的name属性增加一个get属性，当name属性被读取时，触发执行get方法
            console.log("getter已经被调用");
            return name;
        }
    });

</script>
```

### 2. 发布者-订阅者模式的应用
利用上述的数据劫持机制，结合发布者-订阅者模式，我们将整个过程的实现划分为五个组件：观察者Observer，收集器Dep，订阅者Watcher，解释器Complie和集成器MVVM：
+ **Observer: Observer是发布者。Observer利用Object.defineProperty劫持所有响应式对象的所有属性，并通过内部的Dep对象持有着所有的Watcher对象，当存在监听的属性发生变化时，将变化广播给所有的Watcher**

+ **Dep: 位于Observer内部，Dep中存放所有的Watcher，并将从Observer收到的属性改变的消息转发给对应的Watcher**。

+ **Watcher: Watcher是订阅者。Watcher被通知时，检查自己所负责监视的属性是否确实变化（因为Observer通知是广播发送），若变化则调用对应渲染函数进行重新渲染**。

+ **Complie: 解释器的工作是解析html模板，分析出其中的响应式属性并为其生成对应的渲染函数，然后将渲染函数**

+ **MVVM: 集成器将上述的四个组件组装，主要完成以下

三者间的结构图如下所示：

 ![avatar](https://images2015.cnblogs.com/blog/938664/201705/938664-20170522225458132-1434604303.png)


### 3. 观察者Observer的实现
Observer作为发布者-订阅者模式中的发布者，其主要任务有：
+ 属性劫持：对于给定的单个对象，Observer通过Object.defineProperty()方法劫持该对象的所有属性，从而监听该对象中所有属性的变化。
+ 收集Watcher：Observer在内部创建一个收集器Dep对象，将所有新产生的Watcher对象加入到收集器中。
+ 监听属性：属性劫持完成后，Observer监听对象的所有属性，若有某个属性值发生变化，在对应的setter中通知所有Dep中的Watcher对象。

因此，总结而言，Observer在一侧监听着给定对象的所有属性，在另一侧持有着所有的Watcher，当监听的属性发生变化，立刻通知持有的所有Watcher对象。

```
/**
 * Observer: Observer的构造函数
 * @param {*} obj: 需要劫持其所有属性的对象
 */
function Observer(obj) {    
    this.obj=obj;
    this.walk(obj);   
}

Observer.prototype = {
    /**
     * walk: 劫持给定对象的所有属性
     * @param obj: 劫持对象, Object
    */
    walk: function(obj) {
        // 1. 遍历给定对象的每个直接子属性
        let lis=Object.keys(obj);       // Object.keys获取目标对象的子属性列表
        lis.forEach((element) => {      // 这里推荐使用箭头函数，箭头函数捕获该函数所在的上下文的this，并将其作为自己的this，注意只有大括号能够分隔上下文，而小括号不行
            this.defineReactive(obj, element, obj[element]);   // 对列表中的每个子属性，调用defineReactive方法依次进行劫持
        });                  
    },

    /**
     * defineReactive: 对某个属性对象中的给定属性进行劫持
     * @param obj: 需要劫持的属性名所在的属性对象, Object
     * @param key: 需要劫持的属性名, str
     * @param val: 属性名key对应的属性对象, Object
    */
    defineReactive: function(obj, key, val) {
        // 1. 创建一个收集器Dep
        var dep=new Dep();
 
        // 2. 递归地访问并劫持目标属性的所有子属性
        objObserver=observe(val);

        // 3. 使用Object.defineProperty劫持目标属性
        // 3.1 在get中，判断当Watcher对象的缓存Dep.target不为空时，将缓存的新Watcher对象加入收集器Dep，然后重新将缓存清空
        // 3.2 在set中，判断属性的新值不等于旧值时，将消息通知收集器Dep中存放的所有的Watcher对象
        Object.defineProperty(obj, key, {
            set: function(newval) {
                if(newval!=val) {         // 若属性值发生改变
                    console.log("监听到属性发生改变");
                    val=newval;           
                    objObserver=observe(newval); // 易错点: 如果属性改变后的值是一个对象，则需要重新进行监听（因为原来的属性只是单独的一个属性） 
                    dep.notify();                // 通知收集器Dep中的所有的Watcher对象
                }
            },
            get: function() {
                if(Dep.target) {          // 若缓存中存在新的Watcher对象
                    console.log(Dep.target);
                    dep.add(Dep.target);  // 将新的Watcher对象加入收集器Dep
                    Dep.target=null;      // 重新清空缓存，等待下一个新的Watcher对象的到来
                }
                return val;     // 返回属性对象的值
            }
        });
    },
}

/**
 * observe: 外部调用接口，类似于单例模式，仅有传入对象为非空才返回Observer对象
 * @param {*} obj: 要进行劫持的目标对象
 */
function observe(obj) {
    if(!obj||typeof obj!="object") {   // 若传入的需要劫持的对象为空或者传入的不是对象，则不做处理直接返回
        return null;
    }
    else {                             // 传入的需要劫持的对象符合要求时，进行劫持操作
        return new Observer(obj);
    }
}

```

### 4. 订阅器Watcher

